<!doctype html>
<html lang="no">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Oles Brain</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,800&family=Work+Sans:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-top: #f8f2e8;
        --bg-bottom: #e8f0e5;
        --card: #fffdf9;
        --panel: #ffffff;
        --surface: #ffffff;
        --surface-soft: #f7faf7;
        --text: #1f2b1f;
        --muted: #5d6b5f;
        --accent: #2d7f56;
        --accent-pressed: #246545;
        --error: #a73d32;
        --border: #d7dfd5;
        --shadow: 0 18px 42px rgba(34, 53, 40, 0.14);
      }

      :root[data-theme="dark"] {
        --bg-top: #0f1419;
        --bg-bottom: #121a17;
        --card: #131b1f;
        --panel: #172229;
        --surface: #1f2c34;
        --surface-soft: #273741;
        --text: #e8efea;
        --muted: #9bb1a4;
        --accent: #44b97a;
        --accent-pressed: #379b66;
        --error: #ff8d82;
        --border: #2d3a32;
        --shadow: 0 20px 44px rgba(0, 0, 0, 0.46);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        padding: 24px;
        display: grid;
        place-items: center;
        font-family: "Work Sans", sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 15% 15%, rgba(255, 255, 255, 0.8), transparent 38%),
          radial-gradient(circle at 85% 85%, rgba(194, 221, 198, 0.58), transparent 45%),
          linear-gradient(160deg, var(--bg-top), var(--bg-bottom));
        transition: background-color 180ms ease, color 180ms ease;
      }

      .card {
        width: min(1400px, 96vw);
        background: transparent;
        border: none;
        border-radius: 18px;
        padding: 24px;
        box-shadow: none;
        animation: card-enter 380ms ease-out both;
      }

      h1 {
        margin: 0;
        font-family: "Fraunces", serif;
        font-size: clamp(2rem, 5vw, 2.7rem);
        line-height: 1;
      }

      .panel-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 14px;
        margin-top: 20px;
      }

      .panel {
        min-height: clamp(680px, 82vh, 980px);
        padding: 16px;
        border: 1px solid var(--border);
        border-radius: 14px;
        background: var(--panel);
      }

      .mobile-swipe-hint {
        display: none;
        margin: 12px 0 0;
        color: var(--muted);
        font-size: 0.88rem;
      }

      .mobile-page-nav {
        display: none;
        gap: 8px;
        margin-top: 10px;
      }

      .mobile-page-button {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 8px 10px;
        font: inherit;
        font-size: 0.82rem;
        font-weight: 600;
        color: var(--text);
        background: var(--surface);
        cursor: pointer;
      }

      .mobile-page-button.active {
        color: #ffffff;
        border-color: var(--accent);
        background: var(--accent);
      }

      .panel-title {
        margin: 0 0 12px;
        font-family: "Fraunces", serif;
        font-size: clamp(1.2rem, 1.8vw, 1.65rem);
      }

      .dashboard-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 12px;
      }

      .dashboard-header .panel-title {
        margin: 0;
      }

      .sheets-link-button {
        border: 1px solid var(--accent);
        border-radius: 999px;
        padding: 8px 12px;
        font: inherit;
        font-size: 0.82rem;
        font-weight: 700;
        color: #ffffff;
        background: var(--accent);
        cursor: pointer;
        white-space: nowrap;
        transition: transform 120ms ease, background-color 120ms ease;
      }

      .sheets-link-button:hover {
        transform: translateY(-1px);
        background: var(--accent-pressed);
      }

      .sheets-link-button:active {
        transform: translateY(0);
      }

      .sheets-link-button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .dashboard-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-bottom: 12px;
      }

      .dash-card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--surface);
      }

      .dash-label {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .dash-value {
        margin: 6px 0 0;
        font-size: 1.4rem;
        font-weight: 700;
      }

      .dash-observation {
        margin: 8px 0 0;
        color: var(--muted);
        font-size: 0.86rem;
        line-height: 1.35;
      }

      .note-card {
        margin-top: 6px;
      }

      .note-label {
        display: block;
        margin: 0 0 8px;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .note-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
      }

      .note-header-controls {
        display: inline-flex;
        gap: 8px;
      }

      .note-header .note-label {
        margin: 0;
      }

      .note-voice-bubble {
        width: 40px;
        height: 40px;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: var(--text);
        background: var(--surface-soft);
        cursor: pointer;
        transition: transform 140ms ease, background-color 140ms ease, border-color 140ms ease;
      }

      .note-add-button {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0 12px;
        height: 40px;
        font: inherit;
        font-size: 0.82rem;
        font-weight: 600;
        color: var(--text);
        background: var(--surface);
        cursor: pointer;
      }

      .note-add-button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .note-voice-bubble:hover {
        transform: translateY(-1px);
      }

      .note-voice-bubble.active {
        color: #ffffff;
        border-color: var(--accent);
        background: var(--accent);
      }

      .note-voice-bubble:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .note-voice-icon {
        width: 20px;
        height: 20px;
        display: block;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .note-input {
        width: 100%;
        min-height: 220px;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        font: inherit;
        line-height: 1.4;
        color: var(--text);
        background: var(--surface-soft);
        resize: vertical;
      }

      .note-input::placeholder {
        color: var(--muted);
      }

      .note-point-actions {
        margin: 0 0 10px;
      }

      .note-point-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 6px;
      }

      .note-point-item {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--surface);
      }

      .note-point-text {
        margin: 0;
        flex: 1;
        font-size: 0.86rem;
        line-height: 1.35;
      }

      .note-point-remove {
        width: 28px;
        height: 28px;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font: inherit;
        font-size: 1rem;
        font-weight: 700;
        color: var(--text);
        background: var(--surface-soft);
        cursor: pointer;
        flex-shrink: 0;
      }

      .date-input-label {
        display: block;
        margin: 12px 0 8px;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .date-picker {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        font: inherit;
        color: var(--text);
        background: var(--surface);
      }

      .calendar-date-label {
        margin: 8px 0 0;
        color: var(--muted);
        font-size: 0.9rem;
        font-weight: 600;
      }

      .month-calendar {
        margin-top: 6px;
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: var(--surface);
        max-width: 760px;
        margin-inline: auto;
      }

      .month-calendar-header {
        min-height: 54px;
        padding: 7px 9px;
        display: grid;
        grid-template-columns: 36px 1fr 36px;
        align-items: center;
        gap: 8px;
        background: #2d7f56;
      }

      .month-calendar-title {
        margin: 0;
        text-align: center;
        font-size: 1.65rem;
        font-weight: 700;
        color: #ffffff;
      }

      .month-calendar-nav {
        width: 36px;
        height: 36px;
        border: none;
        border-radius: 10px;
        font: inherit;
        font-size: 1.25rem;
        line-height: 1;
        color: #ffffff;
        background: rgba(255, 255, 255, 0.24);
        cursor: pointer;
      }

      .month-calendar-nav:hover {
        background: rgba(255, 255, 255, 0.28);
      }

      .month-calendar-grid {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }

      .month-calendar-grid th,
      .month-calendar-grid td {
        height: 44px;
        text-align: center;
        vertical-align: middle;
      }

      .month-calendar-grid thead th {
        font-size: 0.92rem;
        font-weight: 700;
        color: var(--text);
        background: var(--surface-soft);
      }

      .month-calendar-grid thead th.week-col {
        width: 50px;
        color: var(--muted);
      }

      .month-calendar-grid thead th.sun-col {
        color: #d13e38;
      }

      .month-calendar-grid td {
        border-top: 1px solid var(--border);
      }

      .month-calendar-grid td.week-number {
        font-size: 0.84rem;
        font-style: italic;
        font-weight: 600;
        color: var(--muted);
      }

      .month-calendar-grid td.in-month {
        background: var(--surface);
      }

      .month-calendar-grid td.outside-month {
        color: var(--muted);
        background: var(--surface-soft);
      }

      .month-calendar-grid tr.selected-week td {
        background: rgba(117, 123, 126, 0.18);
      }

      .month-day-button {
        width: 34px;
        height: 34px;
        border: 2px solid transparent;
        border-radius: 0;
        font: inherit;
        font-size: 0.98rem;
        font-weight: 700;
        color: var(--text);
        background: transparent;
        cursor: pointer;
      }

      .month-day-button:hover {
        background: var(--surface-soft);
      }

      .month-day-button.selected {
        border-color: #101010;
        background: #ffffff;
      }

      .month-day-button.today {
        box-shadow: inset 0 -3px 0 var(--accent);
      }

      .month-calendar-grid td.sun-day,
      .month-calendar-grid td.sun-day .month-day-button {
        color: #d13e38;
      }

      :root[data-theme="dark"] .month-calendar-grid tr.selected-week td {
        background: rgba(255, 255, 255, 0.12);
      }

      :root[data-theme="dark"] .month-day-button.selected {
        background: #2d3b43;
      }

      .date-label {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .fixture-quick-list {
        margin: 8px 0 0 18px;
        padding: 0;
        color: var(--muted);
        font-size: 0.9rem;
        display: grid;
        gap: 4px;
      }

      .fixture-quick-list:empty {
        display: none;
      }

      .fixture-quick-list.match {
        color: var(--text);
        font-weight: 600;
      }

      .checklist {
        display: grid;
        gap: 10px;
        margin-top: 10px;
      }

      .item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 14px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--surface);
        cursor: pointer;
        user-select: none;
        transform: translateY(10px);
        opacity: 0;
        animation: item-enter 320ms ease-out forwards;
      }

      .item.completed {
        opacity: 0.62;
        transform: scale(0.98);
        font-size: 0.95rem;
        background: var(--surface-soft);
      }

      .item.completed::after {
        content: "âœ”";
        margin-left: auto;
        font-size: 0.95rem;
        font-weight: 700;
        color: var(--accent);
      }

      .item:nth-of-type(1) {
        animation-delay: 120ms;
      }

      .item:nth-of-type(2) {
        animation-delay: 180ms;
      }

      .item:nth-of-type(3) {
        animation-delay: 240ms;
      }

      .item:nth-of-type(4) {
        animation-delay: 300ms;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin: 0;
        accent-color: var(--accent);
      }

      .status {
        min-height: 1.3em;
        margin: 10px 0 0;
        font-size: 0.95rem;
      }

      .status.success {
        color: var(--accent);
      }

      .status.error {
        color: var(--error);
      }

      .status.pending {
        color: var(--muted);
      }

      .complete {
        margin: 14px 0 0;
        font-weight: 700;
        color: var(--accent);
      }

      .hidden {
        display: none;
      }

      @keyframes card-enter {
        from {
          transform: translateY(8px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes item-enter {
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes view-enter {
        from {
          opacity: 0;
          transform: translateY(4px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 1100px) {
        .panel-grid {
          grid-template-columns: 1fr;
        }

        .panel {
          min-height: clamp(540px, 68vh, 760px);
        }
      }

      @media (max-width: 760px) {
        body {
          display: block;
          padding: 0;
        }

        .card {
          width: 100vw;
          min-height: 100vh;
          border-left: 0;
          border-right: 0;
          border-radius: 0;
          padding: 18px 14px 20px;
        }

        .panel-grid {
          grid-template-columns: none;
          grid-auto-flow: column;
          grid-auto-columns: 100%;
          gap: 12px;
          overflow-x: auto;
          overflow-y: hidden;
          margin-top: 16px;
          scroll-snap-type: x mandatory;
          scroll-padding-inline: 0;
          scrollbar-width: none;
          overscroll-behavior-x: contain;
          -webkit-overflow-scrolling: touch;
        }

        .panel-grid::-webkit-scrollbar {
          display: none;
        }

        .panel {
          min-height: clamp(520px, 72vh, 760px);
          scroll-snap-align: start;
          scroll-snap-stop: always;
        }

        .note-input {
          min-height: 160px;
        }

        .month-calendar-header {
          min-height: 48px;
          padding: 5px 7px;
          grid-template-columns: 32px 1fr 32px;
        }

        .month-calendar-title {
          font-size: 1.3rem;
        }

        .month-calendar-nav {
          width: 32px;
          height: 32px;
          font-size: 1.1rem;
        }

        .month-calendar-grid th,
        .month-calendar-grid td {
          height: 36px;
          font-size: 0.82rem;
        }

        .month-calendar-grid thead th.week-col {
          width: 42px;
        }

        .month-day-button {
          width: 30px;
          height: 30px;
          font-size: 0.88rem;
        }

        .mobile-swipe-hint {
          display: block;
        }

        .mobile-page-nav {
          display: flex;
        }
      }
    </style>
  </head>
  <body>
    <main class="card">
      <p class="mobile-swipe-hint">Sveip sidelengs mellom Dashboard, Rutiner og Kalender.</p>

      <section class="panel-grid" aria-label="Hovedmeny">
        <section class="panel">
          <div class="dashboard-header">
            <h2 class="panel-title">Dashboard</h2>
            <button id="openSheetsButton" class="sheets-link-button" type="button">Ã…pne Sheets</button>
          </div>
          <div class="dashboard-grid">
            <article class="dash-card">
              <p class="dash-label">Skjermtid</p>
              <p id="dashboardScreenTime" class="dash-value">Ikke registrert</p>
              <p id="dashboardScreenTimeObs" class="dash-observation"></p>
            </article>
          </div>
          <article class="dash-card note-card">
            <div class="note-header">
              <label class="note-label" for="dailyNote">Huskeliste</label>
              <div class="note-header-controls">
                <button
                  id="noteAddPointButton"
                  class="note-add-button"
                  type="button"
                  aria-label="Legg til punkt"
                  title="Legg til punkt"
                >
                  Legg til
                </button>
                <button
                  id="noteVoiceButton"
                  class="note-voice-bubble"
                  type="button"
                  aria-label="Snakk inn notat"
                  title="Snakk inn notat"
                >
                  <svg class="note-voice-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M12 4a3 3 0 0 0-3 3v4a3 3 0 1 0 6 0V7a3 3 0 0 0-3-3zm-5 7a1 1 0 1 0-2 0 7 7 0 0 0 6 6.92V20H9a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-2v-2.08A7 7 0 0 0 19 11a1 1 0 1 0-2 0 5 5 0 1 1-10 0z"
                      fill="currentColor"
                    />
                  </svg>
                  <span class="visually-hidden">Snakk inn notat</span>
                </button>
              </div>
            </div>
            <div id="notePointActions" class="note-point-actions"></div>
            <textarea id="dailyNote" class="note-input" placeholder="Skriv noe du vil huske og trykk Legg til..."></textarea>
          </article>
        </section>

        <section class="panel">
          <h2 class="panel-title">Rutiner</h2>
          <p id="dateLabel" class="date-label"></p>

          <section class="checklist">
            <label class="item" data-task="dishwasher">
              <input id="dishwasher" type="checkbox" />
              Oppvaskmaskin
            </label>

            <label class="item" data-task="creatine">
              <input id="creatine" type="checkbox" />
              Kreatin
            </label>

            <label class="item" data-task="omega3">
              <input id="omega3" type="checkbox" />
              Omega-3
            </label>

            <label class="item" data-task="multivitamin">
              <input id="multivitamin" type="checkbox" />
              Multivitamin
            </label>

            <label class="item" data-task="water">
              <input id="water" type="checkbox" />
              2L vann
            </label>

            <label class="item" data-task="bed">
              <input id="bed" type="checkbox" />
              Seng
            </label>

            <label class="item" data-task="workout">
              <input id="workout" type="checkbox" />
              Trening
            </label>
          </section>

          <p id="status" class="status" role="status" aria-live="polite"></p>
          <p id="completeMessage" class="complete hidden">Alle oppgaver gjort ðŸ™‚</p>
        </section>

        <section class="panel">
          <section class="month-calendar" aria-label="MÃ¥nedskalender">
            <header class="month-calendar-header">
              <button id="calendarPrevMonth" class="month-calendar-nav" type="button" aria-label="Forrige mÃ¥ned">
                â€¹
              </button>
              <h3 id="calendarMonthLabel" class="month-calendar-title"></h3>
              <button id="calendarNextMonth" class="month-calendar-nav" type="button" aria-label="Neste mÃ¥ned">
                â€º
              </button>
            </header>
            <table class="month-calendar-grid" aria-label="Kalenderdager">
              <thead>
                <tr>
                  <th class="week-col" scope="col">Uke</th>
                  <th scope="col">Ma</th>
                  <th scope="col">Ti</th>
                  <th scope="col">On</th>
                  <th scope="col">To</th>
                  <th scope="col">Fr</th>
                  <th scope="col">LÃ¸</th>
                  <th class="sun-col" scope="col">SÃ¸</th>
                </tr>
              </thead>
              <tbody id="calendarMonthBody"></tbody>
            </table>
          </section>
          <label class="date-input-label" for="datePicker">Velg dato</label>
          <input id="datePicker" class="date-picker" type="date" />
          <p id="calendarDateLabel" class="calendar-date-label" aria-live="polite"></p>
          <ul id="fixtureQuickList" class="fixture-quick-list" aria-live="polite"></ul>
        </section>
      </section>

      <nav class="mobile-page-nav" aria-label="Panelvalg">
        <button class="mobile-page-button active" type="button" data-panel-index="0">Dashboard</button>
        <button class="mobile-page-button" type="button" data-panel-index="1">Rutiner</button>
        <button class="mobile-page-button" type="button" data-panel-index="2">Kalender</button>
      </nav>
    </main>

    <script>
      const TASKS = ["dishwasher", "creatine", "omega3", "multivitamin", "water", "bed", "workout"];
      const WORKOUT_PLAN_BY_WEEKDAY = {
        0: "LÃ¸ping",
        1: "Push",
        2: "Pull",
        3: "Legs",
        4: "Push",
        5: "Pull"
      };
      const THEME_STORAGE_KEY = "oles-brain-theme";
      const SHEETS_URL_STORAGE_KEY = "oles-brain-sheets-url-v1";
      const DEFAULT_SHEETS_URL =
        "https://docs.google.com/spreadsheets/d/15KvATxIIEMW7877aUDdlIQYddclJdIzb07NJc3ywW0o/edit?gid=2001617319#gid=2001617319";
      const NOTE_SHORTEN_ENDPOINT = "/notes/shorten";
      const MAN_UTD_TEAM_ID = "360";
      const MAN_UTD_CORE_API_BASE = "https://sports.core.api.espn.com/v2/sports/soccer/leagues/eng.1";
      let selectedDate = formatDateToday();
      let calendarViewMonthKey = selectedDate.slice(0, 7);
      let saveQueue = Promise.resolve();
      let fixtures = [];
      let fixturesLoadingPromise = null;
      let fixturesLoaded = false;
      let selectedNoteText = "";
      let selectedNotePoints = [];
      let noteRecognition = null;
      let noteRecognitionSupported = false;
      let noteRecognitionActive = false;
      let noteAddPointBusy = false;

      function emptyDoneState() {
        return {
          dishwasher: 0,
          creatine: 0,
          omega3: 0,
          multivitamin: 0,
          water: 0,
          bed: 0,
          workout: 0
        };
      }

      function emptyScreenTimeState() {
        return {
          totalMinutes: null,
          pickups: null,
          source: "",
          hasData: false
        };
      }

      let selectedDone = emptyDoneState();
      let selectedScreenTime = emptyScreenTimeState();

      function formatDateToday() {
        return new Date().toISOString().slice(0, 10);
      }

      function formatDateLabel(dateIso) {
        const [year, month, day] = dateIso.split("-");
        return `${day}.${month}.${year}`;
      }

      function formatDateLocalIso(dateValue) {
        const year = String(dateValue.getFullYear());
        const month = String(dateValue.getMonth() + 1).padStart(2, "0");
        const day = String(dateValue.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function parseLocalIsoDate(dateIso) {
        const [year, month, day] = String(dateIso || "").split("-").map((value) => Number(value));
        if (!Number.isInteger(year) || !Number.isInteger(month) || !Number.isInteger(day)) {
          return null;
        }

        const parsed = new Date(year, month - 1, day);
        if (
          parsed.getFullYear() !== year ||
          parsed.getMonth() !== month - 1 ||
          parsed.getDate() !== day
        ) {
          return null;
        }

        return parsed;
      }

      function formatWeekdayAndDateLabel(dateIso) {
        const parsed = parseLocalIsoDate(dateIso);
        if (!parsed) {
          return "";
        }

        const weekday = new Intl.DateTimeFormat("nb-NO", {
          weekday: "long"
        }).format(parsed);
        const capitalizedWeekday = weekday.charAt(0).toUpperCase() + weekday.slice(1);
        return capitalizedWeekday;
      }

      function monthKeyFromDateIso(dateIso) {
        const parsed = parseLocalIsoDate(dateIso);
        if (!parsed) {
          return formatDateLocalIso(new Date()).slice(0, 7);
        }

        return formatDateLocalIso(new Date(parsed.getFullYear(), parsed.getMonth(), 1)).slice(0, 7);
      }

      function parseMonthKey(monthKey) {
        const match = String(monthKey || "").match(/^(\d{4})-(\d{2})$/);
        if (!match) {
          return null;
        }

        const year = Number(match[1]);
        const month = Number(match[2]);
        if (!Number.isInteger(year) || !Number.isInteger(month) || month < 1 || month > 12) {
          return null;
        }

        return { year, month };
      }

      function addMonthsToMonthKey(monthKey, delta) {
        const parsed = parseMonthKey(monthKey);
        const base = parsed ? new Date(parsed.year, parsed.month - 1, 1) : new Date();
        base.setMonth(base.getMonth() + delta);
        return `${base.getFullYear()}-${String(base.getMonth() + 1).padStart(2, "0")}`;
      }

      function formatMonthTitle(monthKey) {
        const parsed = parseMonthKey(monthKey);
        if (!parsed) {
          return "";
        }

        const formatted = new Intl.DateTimeFormat("nb-NO", { month: "long", year: "numeric" }).format(
          new Date(parsed.year, parsed.month - 1, 1)
        );
        return formatted.charAt(0).toUpperCase() + formatted.slice(1);
      }

      function startOfWeekMonday(dateValue) {
        const result = new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate());
        const day = result.getDay();
        const offset = day === 0 ? -6 : 1 - day;
        result.setDate(result.getDate() + offset);
        return result;
      }

      function endOfWeekSunday(dateValue) {
        const result = startOfWeekMonday(dateValue);
        result.setDate(result.getDate() + 6);
        return result;
      }

      function isoWeekNumber(dateValue) {
        const utcDate = new Date(Date.UTC(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate()));
        const day = utcDate.getUTCDay() || 7;
        utcDate.setUTCDate(utcDate.getUTCDate() + 4 - day);
        const yearStart = new Date(Date.UTC(utcDate.getUTCFullYear(), 0, 1));
        return Math.ceil((((utcDate - yearStart) / 86400000) + 1) / 7);
      }

      function renderMonthCalendar() {
        const monthBody = document.getElementById("calendarMonthBody");
        const monthLabel = document.getElementById("calendarMonthLabel");
        if (!monthBody || !monthLabel) {
          return;
        }

        const monthParsed = parseMonthKey(calendarViewMonthKey);
        if (!monthParsed) {
          calendarViewMonthKey = monthKeyFromDateIso(selectedDate);
        }

        const activeMonth = parseMonthKey(calendarViewMonthKey);
        if (!activeMonth) {
          return;
        }

        const monthStart = new Date(activeMonth.year, activeMonth.month - 1, 1);
        const monthEnd = new Date(activeMonth.year, activeMonth.month, 0);
        const gridStart = startOfWeekMonday(monthStart);
        const gridEnd = endOfWeekSunday(monthEnd);

        const selectedDateParsed = parseLocalIsoDate(selectedDate);
        const selectedIso = selectedDateParsed ? formatDateLocalIso(selectedDateParsed) : "";
        const todayIso = formatDateToday();

        monthLabel.textContent = formatMonthTitle(calendarViewMonthKey);
        monthBody.replaceChildren();

        const cursor = new Date(gridStart.getFullYear(), gridStart.getMonth(), gridStart.getDate());
        while (cursor <= gridEnd) {
          const weekStart = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate());
          const weekEnd = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate());
          weekEnd.setDate(weekEnd.getDate() + 6);

          const row = document.createElement("tr");
          if (selectedDateParsed && selectedDateParsed >= weekStart && selectedDateParsed <= weekEnd) {
            row.classList.add("selected-week");
          }

          const weekCell = document.createElement("td");
          weekCell.className = "week-number";
          weekCell.textContent = String(isoWeekNumber(weekStart));
          row.appendChild(weekCell);

          for (let dayOffset = 0; dayOffset < 7; dayOffset += 1) {
            const day = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate());
            day.setDate(day.getDate() + dayOffset);

            const cell = document.createElement("td");
            const inMonth = day.getMonth() === monthStart.getMonth();
            const dayIso = formatDateLocalIso(day);
            if (dayOffset === 6) {
              cell.classList.add("sun-day");
            }

            if (!inMonth) {
              cell.classList.add("outside-month");
              row.appendChild(cell);
              continue;
            }

            cell.classList.add("in-month");

            const dayButton = document.createElement("button");
            dayButton.type = "button";
            dayButton.className = "month-day-button";
            dayButton.dataset.calendarDate = dayIso;
            dayButton.textContent = String(day.getDate());
            dayButton.setAttribute("aria-label", `${formatWeekdayAndDateLabel(dayIso)} ${formatDateLabel(dayIso)}`);

            if (dayIso === selectedIso) {
              dayButton.classList.add("selected");
              dayButton.setAttribute("aria-current", "date");
            }

            if (dayIso === todayIso) {
              dayButton.classList.add("today");
            }

            cell.appendChild(dayButton);
            row.appendChild(cell);
          }

          monthBody.appendChild(row);
          cursor.setDate(cursor.getDate() + 7);
        }
      }

      function workoutPlanForDate(dateIso) {
        const parsed = parseLocalIsoDate(dateIso);
        if (!parsed) {
          return null;
        }

        const weekday = parsed.getDay();
        const workout = WORKOUT_PLAN_BY_WEEKDAY[weekday];
        if (!workout) {
          return {
            type: "rest",
            text: "Planlagt Ã¸kt: Hvile / restitusjon."
          };
        }

        return {
          type: "workout",
          text: `Planlagt Ã¸kt: ${workout}.`
        };
      }

      function requiredTasksForDate(dateIso) {
        const workoutPlan = workoutPlanForDate(dateIso);
        const workoutRequired = workoutPlan && workoutPlan.type === "workout";
        return TASKS.filter((task) => (task === "workout" ? workoutRequired : true));
      }

      function formatFixtureTime(dateIso) {
        const parsed = new Date(dateIso);
        if (Number.isNaN(parsed.getTime())) {
          return "";
        }

        return new Intl.DateTimeFormat("nb-NO", {
          hour: "2-digit",
          minute: "2-digit"
        }).format(parsed);
      }

      function currentPremierLeagueSeasonStartYear(date = new Date()) {
        const month = date.getUTCMonth();
        const year = date.getUTCFullYear();
        return month >= 6 ? year : year - 1;
      }

      function seasonEventsIndexUrl(seasonStartYear) {
        return `${MAN_UTD_CORE_API_BASE}/seasons/${seasonStartYear}/types/1/teams/${MAN_UTD_TEAM_ID}/events?limit=200`;
      }

      function coreEventUrl(eventId) {
        return `${MAN_UTD_CORE_API_BASE}/events/${encodeURIComponent(eventId)}?lang=en&region=us`;
      }

      function eventIdFromRef(ref) {
        const match = String(ref || "").match(/\/events\/(\d+)/);
        return match ? match[1] : null;
      }

      function parseFixtureDetails(event) {
        const fullName = typeof event.name === "string" ? event.name : "";
        const awayPrefix = "Manchester United at ";
        const homeSuffix = " at Manchester United";

        if (fullName.startsWith(awayPrefix)) {
          return {
            opponent: fullName.slice(awayPrefix.length).trim() || "Motstander",
            isHome: false
          };
        }

        if (fullName.endsWith(homeSuffix)) {
          return {
            opponent: fullName.slice(0, -homeSuffix.length).trim() || "Motstander",
            isHome: true
          };
        }

        const shortName = typeof event.shortName === "string" ? event.shortName : "";
        const [left, right] = shortName.split("@").map((part) => (part ? part.trim() : ""));
        if (left && right) {
          if (left === "MAN") {
            return { opponent: right, isHome: false };
          }
          if (right === "MAN") {
            return { opponent: left, isHome: true };
          }
        }

        return { opponent: "Motstander", isHome: true };
      }

      function tournamentNameFromEvent(event) {
        const leagueRef = event && event.league && event.league.$ref;
        if (typeof leagueRef === "string" && leagueRef.includes("/leagues/eng.1")) {
          return "Premier League";
        }

        return "Premier League";
      }

      function normalizeCoreEvent(event) {
        if (!event || typeof event.date !== "string") {
          return null;
        }

        const details = parseFixtureDetails(event);
        return {
          id: String(event.id || `${event.date}-${event.shortName || "fixture"}`),
          date: event.date.slice(0, 10),
          kickoffIso: event.date,
          opponent: details.opponent,
          isHome: details.isHome,
          tournament: tournamentNameFromEvent(event)
        };
      }

      async function fetchFixturesForSeason(seasonStartYear) {
        const indexResponse = await fetch(seasonEventsIndexUrl(seasonStartYear), { cache: "no-store" });
        if (!indexResponse.ok) {
          throw new Error(`Kunne ikke hente kampliste for sesong ${seasonStartYear}`);
        }

        const indexBody = await indexResponse.json();
        const items = Array.isArray(indexBody.items) ? indexBody.items : [];
        const eventIds = Array.from(
          new Set(
            items
              .map((item) => eventIdFromRef(item && item.$ref))
              .filter(Boolean)
          )
        );

        if (eventIds.length === 0) {
          return [];
        }

        const eventResults = await Promise.allSettled(
          eventIds.map(async (eventId) => {
            const response = await fetch(coreEventUrl(eventId), { cache: "no-store" });
            if (!response.ok) {
              throw new Error(`Kunne ikke hente kamp ${eventId}`);
            }
            return response.json();
          })
        );

        return eventResults
          .filter((result) => result.status === "fulfilled")
          .map((result) => normalizeCoreEvent(result.value))
          .filter(Boolean)
          .sort((a, b) => new Date(a.kickoffIso) - new Date(b.kickoffIso));
      }

      function renderFixtures() {
        const quickList = document.getElementById("fixtureQuickList");
        if (!quickList) {
          return;
        }

        quickList.className = "fixture-quick-list";
        quickList.replaceChildren();

        const workoutPlan = workoutPlanForDate(selectedDate);
        if (workoutPlan) {
          const workoutItem = document.createElement("li");
          workoutItem.textContent = workoutPlan.text;
          quickList.appendChild(workoutItem);
          quickList.classList.add("match");
        }

        if (!fixturesLoaded) {
          return;
        }

        const selectedDateFixtures = fixtures
          .filter((fixture) => fixture.date === selectedDate)
          .sort((a, b) => new Date(a.kickoffIso) - new Date(b.kickoffIso));

        if (selectedDateFixtures.length === 0) {
          return;
        }

        selectedDateFixtures.forEach((fixture) => {
          const kickoff = formatFixtureTime(fixture.kickoffIso);
          const homeAwayShort = fixture.isHome ? "H" : "B";
          const item = document.createElement("li");

          if (kickoff) {
            item.textContent = `Man Utd ${kickoff} vs ${fixture.opponent} (${homeAwayShort})`;
          } else {
            item.textContent = `Man Utd vs ${fixture.opponent} (${homeAwayShort})`;
          }

          quickList.appendChild(item);
        });

        quickList.classList.add("match");
      }

      async function loadManchesterUnitedFixtures() {
        if (fixturesLoadingPromise) {
          return fixturesLoadingPromise;
        }

        renderFixtures();

        fixturesLoadingPromise = (async () => {
          try {
            const seasonStartYear = currentPremierLeagueSeasonStartYear();
            const seasonCandidates = Array.from(new Set([seasonStartYear, seasonStartYear - 1, seasonStartYear + 1]));
            let loadedFixtures = [];

            for (const season of seasonCandidates) {
              const seasonFixtures = await fetchFixturesForSeason(season);
              if (seasonFixtures.length > 0) {
                loadedFixtures = seasonFixtures;
                break;
              }
            }

            if (loadedFixtures.length === 0) {
              throw new Error("Ingen kamper funnet");
            }

            fixtures = loadedFixtures;
            fixturesLoaded = true;
          } catch (_) {
            fixtures = [];
            fixturesLoaded = false;
          } finally {
            fixturesLoadingPromise = null;
            renderFixtures();
          }
        })();

        return fixturesLoadingPromise;
      }

      function setStatus(message, type) {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = `status ${type || ""}`.trim();
      }

      function readSheetsUrlFromStorage() {
        try {
          return String(localStorage.getItem(SHEETS_URL_STORAGE_KEY) || "").trim();
        } catch (_) {
          return "";
        }
      }

      function saveSheetsUrlToStorage(url) {
        try {
          localStorage.setItem(SHEETS_URL_STORAGE_KEY, url);
        } catch (_) {}
      }

      function isValidGoogleSheetsUrl(url) {
        try {
          const parsed = new URL(url);
          return parsed.protocol === "https:" && parsed.hostname === "docs.google.com" && parsed.pathname.startsWith("/spreadsheets/");
        } catch (_) {
          return false;
        }
      }

      function setupSheetsButton() {
        const button = document.getElementById("openSheetsButton");
        if (!button) {
          return;
        }

        button.title = "Ã…pne Google Sheets (hold Shift for Ã¥ endre lenke)";

        button.addEventListener("click", (event) => {
          let sheetsUrl = readSheetsUrlFromStorage();
          const forceNewUrl = event.shiftKey;
          if (!forceNewUrl && !isValidGoogleSheetsUrl(sheetsUrl) && isValidGoogleSheetsUrl(DEFAULT_SHEETS_URL)) {
            sheetsUrl = DEFAULT_SHEETS_URL;
          }

          if (forceNewUrl || !isValidGoogleSheetsUrl(sheetsUrl)) {
            const enteredUrl = window.prompt(
              "Lim inn lenken til Google Sheets-dokumentet ditt (lagres lokalt i nettleseren):",
              "https://docs.google.com/spreadsheets/d/..."
            );

            if (!enteredUrl) {
              return;
            }

            sheetsUrl = enteredUrl.trim();
            if (!isValidGoogleSheetsUrl(sheetsUrl)) {
              window.alert("Ugyldig Sheets-lenke. Bruk en docs.google.com/spreadsheets-lenke.");
              return;
            }

            saveSheetsUrlToStorage(sheetsUrl);
          }

          window.open(sheetsUrl, "_blank", "noopener,noreferrer");
        });
      }

      function allDone(doneState, dateIso) {
        const requiredTasks = requiredTasksForDate(dateIso);
        return requiredTasks.every((task) => doneState[task] === 1);
      }

      function toNonNegativeIntegerOrNull(value) {
        return Number.isInteger(value) && value >= 0 ? value : null;
      }

      function formatMinutes(totalMinutes) {
        const value = toNonNegativeIntegerOrNull(totalMinutes);
        if (value === null) {
          return "Ikke registrert";
        }

        const hours = Math.floor(value / 60);
        const minutes = value % 60;

        if (hours === 0) {
          return `${minutes} min`;
        }

        if (minutes === 0) {
          return `${hours} t`;
        }

        return `${hours} t ${minutes} min`;
      }

      function updateDateLabel() {
        const today = formatDateToday();
        const suffix = selectedDate === today ? " (i dag)" : "";
        const formattedDate = `${formatDateLabel(selectedDate)}${suffix}`;

        const routineLabel = document.getElementById("dateLabel");
        const calendarDateLabel = document.getElementById("calendarDateLabel");

        routineLabel.textContent = `Viser dato: ${formattedDate}`;
        if (calendarDateLabel) {
          calendarDateLabel.textContent = formatWeekdayAndDateLabel(selectedDate);
        }
        renderMonthCalendar();
        renderFixtures();
      }

      function updateDashboard() {
        const dashboardScreenTime = document.getElementById("dashboardScreenTime");
        const dashboardScreenTimeObs = document.getElementById("dashboardScreenTimeObs");

        if (dashboardScreenTime) {
          dashboardScreenTime.textContent = formatMinutes(selectedScreenTime.totalMinutes);
        }

        if (dashboardScreenTimeObs) {
          if (!selectedScreenTime.hasData || selectedScreenTime.totalMinutes === null) {
            dashboardScreenTimeObs.textContent = "Observasjon: Ingen skjermtid registrert for valgt dato ennÃ¥.";
          } else {
            const durationText = formatMinutes(selectedScreenTime.totalMinutes);
            const pickupsText =
              selectedScreenTime.pickups === null ? "" : `, ${selectedScreenTime.pickups} opplÃ¥singer`;
            const sourceText = selectedScreenTime.source ? ` (kilde: ${selectedScreenTime.source})` : "";
            dashboardScreenTimeObs.textContent = `Observasjon: ${durationText}${pickupsText}${sourceText}.`;
          }
        }
      }

      function syncNoteInput() {
        const noteInput = document.getElementById("dailyNote");
        if (!noteInput) {
          return;
        }

        if (noteInput.value !== selectedNoteText) {
          noteInput.value = selectedNoteText;
        }

        renderNotePointActions();
        updateAddPointButton();
      }

      function notePointsFromStoredNote(value) {
        return String(value || "")
          .replace(/\r\n/g, "\n")
          .split("\n")
          .map((line) => normalizePointText(line))
          .filter(Boolean);
      }

      function composeStoredNoteFromPoints(points) {
        const cleanPoints = Array.isArray(points) ? points.map((point) => normalizePointText(point)).filter(Boolean) : [];
        if (cleanPoints.length === 0) {
          return "";
        }

        return cleanPoints.map((point) => `â€¢ ${point}`).join("\n");
      }

      function applySelectedState() {
        const requiredTaskSet = new Set(requiredTasksForDate(selectedDate));
        const doneEverything = allDone(selectedDone, selectedDate);
        const completeMessage = document.getElementById("completeMessage");

        TASKS.forEach((task) => {
          const item = document.querySelector(`[data-task="${task}"]`);
          const checkbox = document.getElementById(task);
          const done = selectedDone[task] === 1;
          const isRequired = requiredTaskSet.has(task);

          if (item) {
            item.classList.toggle("hidden", !isRequired);
            item.classList.toggle("completed", isRequired && done);
          }

          if (checkbox) {
            checkbox.disabled = !isRequired;
            checkbox.checked = done;
          }
        });

        completeMessage.classList.toggle("hidden", !doneEverything);
        updateDashboard();

        if (doneEverything) {
          setStatus("Alle oppgaver gjort for valgt dato ðŸ™‚", "success");
        }
      }

      async function loadSelectedDateState() {
        try {
          const response = await fetch(`/entries/today?date=${encodeURIComponent(selectedDate)}`);
          if (response.ok) {
            const body = await response.json();
            selectedDone = {
              dishwasher: body.dishwasher === 1 ? 1 : 0,
              creatine: body.creatine === 1 ? 1 : 0,
              omega3: body.omega3 === 1 ? 1 : 0,
              multivitamin: body.multivitamin === 1 ? 1 : 0,
              water: body.water === 1 ? 1 : 0,
              bed: body.bed === 1 ? 1 : 0,
              workout: body.workout === 1 ? 1 : 0
            };
            selectedNotePoints = notePointsFromStoredNote(body && typeof body.note === "string" ? body.note : "");
            selectedNoteText = "";
          } else {
            selectedDone = emptyDoneState();
            selectedNotePoints = [];
            selectedNoteText = "";
          }
        } catch (_) {
          selectedDone = emptyDoneState();
          selectedNotePoints = [];
          selectedNoteText = "";
        }

        try {
          const response = await fetch(`/screen-time/today?date=${encodeURIComponent(selectedDate)}`);
          if (response.ok) {
            const body = await response.json();
            const totalMinutes = toNonNegativeIntegerOrNull(body.total_minutes);
            const pickups = toNonNegativeIntegerOrNull(body.pickups);

            selectedScreenTime = {
              totalMinutes,
              pickups,
              source: typeof body.source === "string" ? body.source : "",
              hasData: body.has_data === true && totalMinutes !== null
            };
          } else {
            selectedScreenTime = emptyScreenTimeState();
          }
        } catch (_) {
          selectedScreenTime = emptyScreenTimeState();
        }

        updateDateLabel();
        applySelectedState();
        syncNoteInput();
      }

      function buildPayload(date, doneState, notePoints) {
        return {
          date,
          dishwasher: doneState.dishwasher === 1 ? 1 : 0,
          creatine: doneState.creatine === 1 ? 1 : 0,
          omega3: doneState.omega3 === 1 ? 1 : 0,
          multivitamin: doneState.multivitamin === 1 ? 1 : 0,
          water: doneState.water === 1 ? 1 : 0,
          bed: doneState.bed === 1 ? 1 : 0,
          workout: doneState.workout === 1 ? 1 : 0,
          note: composeStoredNoteFromPoints(notePoints)
        };
      }

      async function persistEntry(date, doneState, notePoints) {
        const payload = buildPayload(date, doneState, notePoints);

        try {
          const response = await fetch("/entries", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorBody = await response.json().catch(() => ({}));
            if (selectedDate === date) {
              setStatus(errorBody.error || "Kunne ikke lagre automatisk", "error");
            }
            return;
          }

          if (selectedDate === date) {
            setStatus("Lagret automatisk", "success");
          }
        } catch (_) {
          if (selectedDate === date) {
            setStatus("Nettverksfeil (ikke lagret)", "error");
          }
        }
      }

      function queueAutoSave() {
        const dateSnapshot = selectedDate;
        const doneSnapshot = { ...selectedDone };
        const notePointsSnapshot = [...selectedNotePoints];

        if (selectedDate === dateSnapshot) {
          setStatus("Lagrer...", "pending");
        }

        saveQueue = saveQueue.then(() => persistEntry(dateSnapshot, doneSnapshot, notePointsSnapshot));
      }

      function normalizePointText(value) {
        const cleaned = String(value || "").replace(/\s+/g, " ").trim();
        return cleaned.replace(/^[â€¢*-]\s*/, "").trim();
      }

      function updateAddPointButton() {
        const button = document.getElementById("noteAddPointButton");
        if (!button) {
          return;
        }

        button.disabled = noteAddPointBusy || selectedNoteText.trim() === "";
      }

      async function shortenNoteText(value) {
        const input = normalizePointText(value);
        if (!input) {
          return "";
        }

        try {
          const response = await fetch(NOTE_SHORTEN_ENDPOINT, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ text: input })
          });

          if (!response.ok) {
            throw new Error(`Korting feilet (${response.status})`);
          }

          const body = await response.json();
          const shortText = normalizePointText(body && typeof body.short_text === "string" ? body.short_text : "");
          return shortText || input;
        } catch (_) {
          return input;
        }
      }

      function renderNotePointActions() {
        const container = document.getElementById("notePointActions");
        if (!container) {
          return;
        }

        container.replaceChildren();
        if (selectedNotePoints.length === 0) {
          return;
        }

        const list = document.createElement("ul");
        list.className = "note-point-list";

        selectedNotePoints.forEach((pointText, pointIndex) => {
          const item = document.createElement("li");
          item.className = "note-point-item";

          const removeButton = document.createElement("button");
          removeButton.type = "button";
          removeButton.className = "note-point-remove";
          removeButton.setAttribute("aria-label", "Fjern punkt");
          removeButton.title = "Fjern punkt";
          removeButton.dataset.removePointIndex = String(pointIndex);
          removeButton.textContent = "Ã—";

          const text = document.createElement("p");
          text.className = "note-point-text";
          text.textContent = pointText;

          item.appendChild(removeButton);
          item.appendChild(text);
          list.appendChild(item);
        });

        container.appendChild(list);
      }

      function removeNotePointByIndex(pointIndex) {
        if (!Number.isInteger(pointIndex) || pointIndex < 0 || pointIndex >= selectedNotePoints.length) {
          return;
        }

        selectedNotePoints.splice(pointIndex, 1);
        renderNotePointActions();
        queueAutoSave();
      }

      async function addTypedTextToPoints() {
        const noteInput = document.getElementById("dailyNote");
        if (!noteInput) {
          return;
        }

        if (noteAddPointBusy) {
          return;
        }

        const rawLines = selectedNoteText.replace(/\r\n/g, "\n").split("\n");
        const inputLines = rawLines.map((line) => normalizePointText(line)).filter(Boolean);
        if (inputLines.length === 0) {
          updateAddPointButton();
          return;
        }

        noteAddPointBusy = true;
        updateAddPointButton();
        try {
          const shortenedLines = await Promise.all(inputLines.map((line) => shortenNoteText(line)));
          const newPoints = shortenedLines.map((line) => normalizePointText(line)).filter(Boolean);
          if (newPoints.length === 0) {
            return;
          }

          selectedNotePoints.push(...newPoints);
          selectedNoteText = "";
          noteInput.value = "";
          renderNotePointActions();
          queueAutoSave();
        } finally {
          noteAddPointBusy = false;
          updateAddPointButton();
        }
      }

      function updateNoteVoiceButton() {
        const button = document.getElementById("noteVoiceButton");
        if (!button) {
          return;
        }

        if (!noteRecognitionSupported) {
          button.setAttribute("aria-label", "Mikrofon ikke tilgjengelig");
          button.title = "Mikrofon ikke tilgjengelig";
          button.disabled = true;
          button.classList.remove("active");
          return;
        }

        button.disabled = false;
        if (noteRecognitionActive) {
          button.classList.add("active");
          button.setAttribute("aria-label", "Stopp taleopptak");
          button.title = "Stopp taleopptak";
        } else {
          button.classList.remove("active");
          button.setAttribute("aria-label", "Snakk inn notat");
          button.title = "Snakk inn notat";
        }
      }

      async function appendVoiceTextToNote(text) {
        const cleanText = typeof text === "string" ? text.replace(/\s+/g, " ").trim() : "";
        if (!cleanText) {
          return;
        }

        const shortText = await shortenNoteText(cleanText);
        if (!shortText) {
          return;
        }

        selectedNotePoints.push(shortText);
        renderNotePointActions();
        updateAddPointButton();
        queueAutoSave();
      }

      function setupNoteVoiceInput() {
        const button = document.getElementById("noteVoiceButton");
        if (!button) {
          return;
        }

        const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognitionCtor) {
          noteRecognitionSupported = false;
          updateNoteVoiceButton();
          return;
        }

        noteRecognitionSupported = true;
        noteRecognition = new SpeechRecognitionCtor();
        noteRecognition.lang = "nb-NO";
        noteRecognition.continuous = false;
        noteRecognition.interimResults = false;

        noteRecognition.onstart = () => {
          noteRecognitionActive = true;
          updateNoteVoiceButton();
        };

        noteRecognition.onend = () => {
          noteRecognitionActive = false;
          updateNoteVoiceButton();
        };

        noteRecognition.onerror = () => {
          noteRecognitionActive = false;
          updateNoteVoiceButton();
        };

        noteRecognition.onresult = (event) => {
          let finalText = "";
          for (let index = event.resultIndex; index < event.results.length; index += 1) {
            const result = event.results[index];
            if (result && result.isFinal && result[0] && typeof result[0].transcript === "string") {
              finalText += result[0].transcript;
            }
          }
          void appendVoiceTextToNote(finalText);
        };

        button.addEventListener("click", () => {
          if (!noteRecognitionSupported || !noteRecognition) {
            return;
          }

          if (noteRecognitionActive) {
            noteRecognition.stop();
            return;
          }

          try {
            noteRecognition.start();
          } catch (_) {
            noteRecognitionActive = false;
            updateNoteVoiceButton();
          }
        });

        updateNoteVoiceButton();
      }

      function setupTaskToggles() {
        TASKS.forEach((task) => {
          const checkbox = document.getElementById(task);
          if (!checkbox) {
            return;
          }

          checkbox.addEventListener("change", () => {
            selectedDone[task] = checkbox.checked ? 1 : 0;
            applySelectedState();
            queueAutoSave();
          });
        });
      }

      function setupNoteInput() {
        const noteInput = document.getElementById("dailyNote");
        if (!noteInput) {
          return;
        }

        noteInput.addEventListener("input", () => {
          selectedNoteText = noteInput.value;
          renderNotePointActions();
          updateAddPointButton();
        });
      }

      function setupNoteAddPoint() {
        const addButton = document.getElementById("noteAddPointButton");
        if (!addButton) {
          return;
        }

        addButton.addEventListener("click", () => {
          void addTypedTextToPoints();
        });

        updateAddPointButton();
      }

      function setupNotePointActions() {
        const container = document.getElementById("notePointActions");
        if (!container) {
          return;
        }

        container.addEventListener("click", (event) => {
          const target = event.target;
          if (!(target instanceof Element)) {
            return;
          }

          const button = target.closest("[data-remove-point-index]");
          if (!button) {
            return;
          }

          const pointIndex = Number(button.getAttribute("data-remove-point-index"));
          if (!Number.isInteger(pointIndex)) {
            return;
          }

          removeNotePointByIndex(pointIndex);
        });

        renderNotePointActions();
      }

      function setupDateControls() {
        const datePicker = document.getElementById("datePicker");

        datePicker.value = selectedDate;

        datePicker.addEventListener("change", async () => {
          if (!datePicker.value) {
            return;
          }

          if (noteRecognition && noteRecognitionActive) {
            noteRecognition.stop();
          }
          await saveQueue;
          selectedDate = datePicker.value;
          calendarViewMonthKey = monthKeyFromDateIso(selectedDate);
          setStatus("", "");
          await loadSelectedDateState();
        });
      }

      function setupMonthCalendar() {
        const monthBody = document.getElementById("calendarMonthBody");
        const previousMonthButton = document.getElementById("calendarPrevMonth");
        const nextMonthButton = document.getElementById("calendarNextMonth");
        const datePicker = document.getElementById("datePicker");

        if (!monthBody || !previousMonthButton || !nextMonthButton || !datePicker) {
          return;
        }

        previousMonthButton.addEventListener("click", () => {
          calendarViewMonthKey = addMonthsToMonthKey(calendarViewMonthKey, -1);
          renderMonthCalendar();
        });

        nextMonthButton.addEventListener("click", () => {
          calendarViewMonthKey = addMonthsToMonthKey(calendarViewMonthKey, 1);
          renderMonthCalendar();
        });

        monthBody.addEventListener("click", async (event) => {
          const target = event.target;
          if (!(target instanceof Element)) {
            return;
          }

          const dayButton = target.closest("[data-calendar-date]");
          if (!dayButton) {
            return;
          }

          const nextDate = String(dayButton.getAttribute("data-calendar-date") || "");
          if (!parseLocalIsoDate(nextDate) || nextDate === selectedDate) {
            return;
          }

          if (noteRecognition && noteRecognitionActive) {
            noteRecognition.stop();
          }

          await saveQueue;
          selectedDate = nextDate;
          datePicker.value = nextDate;
          setStatus("", "");
          await loadSelectedDateState();
        });

        renderMonthCalendar();
      }

      function applyTheme(theme) {
        const root = document.documentElement;
        const isDark = theme === "dark";

        root.setAttribute("data-theme", isDark ? "dark" : "light");
      }

      function setupTheme() {
        const preferredTheme = window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";
        const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);
        const initialTheme = savedTheme === "dark" || savedTheme === "light" ? savedTheme : preferredTheme;

        applyTheme(initialTheme);
      }

      function setupMobilePanelNavigation() {
        const panelGrid = document.querySelector(".panel-grid");
        const panels = Array.from(panelGrid ? panelGrid.querySelectorAll(".panel") : []);
        const buttons = Array.from(document.querySelectorAll(".mobile-page-button"));

        if (!panelGrid || panels.length === 0 || buttons.length === 0) {
          return;
        }

        let activeIndex = 0;
        let ticking = false;

        function setActiveButton(index) {
          buttons.forEach((button) => {
            button.classList.toggle("active", Number(button.dataset.panelIndex) === index);
          });
        }

        function scrollToPanel(index) {
          const targetPanel = panels[index];
          if (!targetPanel) {
            return;
          }

          panelGrid.scrollTo({
            left: targetPanel.offsetLeft,
            behavior: "smooth"
          });
          activeIndex = index;
          setActiveButton(index);
        }

        function findClosestPanelIndex() {
          const currentScroll = panelGrid.scrollLeft;
          let closestIndex = 0;
          let smallestDistance = Number.POSITIVE_INFINITY;

          panels.forEach((panel, index) => {
            const distance = Math.abs(panel.offsetLeft - currentScroll);
            if (distance < smallestDistance) {
              smallestDistance = distance;
              closestIndex = index;
            }
          });

          return closestIndex;
        }

        buttons.forEach((button) => {
          button.addEventListener("click", () => {
            const index = Number(button.dataset.panelIndex);
            scrollToPanel(index);
          });
        });

        panelGrid.addEventListener(
          "scroll",
          () => {
            if (ticking) {
              return;
            }

            ticking = true;
            window.requestAnimationFrame(() => {
              const closestIndex = findClosestPanelIndex();
              if (closestIndex !== activeIndex) {
                activeIndex = closestIndex;
                setActiveButton(closestIndex);
              }
              ticking = false;
            });
          },
          { passive: true }
        );

        setActiveButton(activeIndex);
      }

      setupTheme();
      setupDateControls();
      setupMonthCalendar();
      setupTaskToggles();
      setupNoteInput();
      setupNoteAddPoint();
      setupNotePointActions();
      setupNoteVoiceInput();
      setupSheetsButton();
      setupMobilePanelNavigation();
      loadSelectedDateState();
      loadManchesterUnitedFixtures();
    </script>
  </body>
</html>
